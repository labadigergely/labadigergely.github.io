---
title: Távoli olvasó továbbolvas
layout: post
categories: szovegek
tags: R distant&nbsp;reading tutorial
---

## Mit és hogyan, eddig?
Az előző [blogposzt](http://labadigergely.github.io/szovegek/2016/12/04/R1/) egy egyszerű, gyorstalpaló bevezetés a [distant reading][distant]-be gyakorlatába. Néhány példán keresztül bemutattam/bevezettem néhány alapeszközt: egy magyar nyelvre készített morfológiai elemzőt ([magyarlanc][magyarlanc]), az [R][r]-t, egy statisztikai programot, ennek felhasználóbarátabb felületét az [RStudio][rstudio]-t – és megemlítettem a [Stylo][stylo]-t is, ami az `R`-hez készített programcsomag. A példák egyszerűek voltak, leginkább néhány alapművelet, nem sok köze van a [distant reading][distant] tényleges gyakorlatához, bár néhány dolog így is egyértelmű: iszonyú gyorsan lehet a szövegeket manipulálni. Most egy újabb ízelítő. Olyan műveletek, amelyek azért már közelebb vannak hozzá. Jockers ezeket az elemzéseket zömében *microanalysis*nek nevezi – megkülönböztetve még a *mezo-* és az *macroanalysis*t.
> Az előző blogposztban létrehozott változókat adottnak veszem. Amikor ki akarunk lépni az [RStudio][rstudio]-ból, akkor mindig rákérdez, el akarjuk-e menteni. Mondjuk neki nyugodtan igent. Akkor legközelebb betölti az addigi munkánkat. A különböző munkákat érdemes külön-külön menteni, ehhez a legjobb külön projektek indítása/mentése – értelemszerűen a `File` menüből.


## 1. További alapműveletek és egy kevés elemzés

### 1.1. Kisbetűsítés
- Az előző posztban *Az arany ember* [Magyar Elektronikus Könyvtárból letöltött kritikai kiadásából készített](http://mek.oszk.hu/05500/05571/index.phtml) `.txt` fájlját közvetlenül is betöltöttük az `R`-be `aranyember.v` néven.

> És akkor megszakítom az adást: én eredetileg az `.epub`-verziót konvertáltam `.txt` formátumúra a [Calibre][calibre]-vel. Amikor a változók közti különbségek okát próbáltam megérteni, mellékesen rájöttem, hogy az egyik fejezet, *Dódi levele* hibás, egy másik fejezet szövegét is tartalmazza. Tehát ha az `.epub` alapján csinálta valaki – mint én – akkor érdemes mindent újracsinálni.

- Ha megnézzük az elejét (emlékeztetőül: `head(aranyember.v,n=3)`), láthatjuk, hogy ez tényleg bekezdésenként tárolja a szöveget, valamint, hogy kis- és nagybetűk még megmaradtak, szemben a `magyarlanc`-cal végzett elemzés után behívott fájllal. Kisbetűsítsük tehát:

```R
kisbetus.aranyember.v = tolower(aranyember.v)
```

### 1.2. Szógazdagság – egyedi szavak száma
- Ennek lekérdezése már egy valódi elemzési szempont. Ti. nemcsak az lehet egy szöveggel kapcsolatban kérdés, hogy hány szóból (jelből) áll, hanem az is, hány egyedi kifejezésből, vagy az előző blogposzt terminológiája nyomán hány lemmából (jeltípusból).
    - Ennek rendes tudományos neve is van: *Type-Token Ratio*, vagy magyarul Antal László nyomán [Bencziktől](http://mek.oszk.hu/05100/05153/) átvéve: típus–jel-viszony (a fordítottja pedig a jel–típus-viszony). Erről (ezekről) sokféle elképzelést olvashatunk, hogy ti. melyik milyen arányok jellemzők inkább a szóbeli, szóbeliséget imitáló szövegekre, a költői alkotásokra stb. Mindenki döntse el maga – az 1960-as és '70-es években sok ilyen szöveget írtak magyarul is (pl. [Zsilka Tibor](http://www.krudy.hu/Szakirod/ZsilkaTibor/ZsiTAnum_71.html)). Annyival viszont beljebb vagyunk, hogy gyorsabban tudjuk ezeket a vizsgálatokat elvégezni, illetve mivel megadjuk, melyik programot használjuk, ellenőrizhetők is vagyunk. És többféle szempontot lehet kombinálni (majd egy másik blogposztban).
    - Maga a parancs roppant egyszerű, az eredményeket el is tudjuk menteni. Ám előtte az `aranyember.v` változóval is végezzük el azt a feladatot, amelyet a `magyarlanc`-cal elemzett szöveggel is megtettünk (a `>` ismét az `RStudio` konzolján jelenik meg, a `#` pedig az én kommentárom, egyiket sem kell begépelni/bemásolni).

```R
# mivel bekezdésenként tárolja, ezért előbb összemásoljuk a bekezdéseket
> ae.v = paste(aranyember.v, collapse = " ")
# kisbetűsítjük a változót
> ae.lower.v = tolower(ae.v)
# a kisbetűs változatból kivesszük az írásjeleket
ae.lower.l = strsplit(ae.lower.v, "\\W")
# a listaformátumú változót visszaalakítjuk karaktervektorrá
> ae2.v = unlist(ae.lower.l)
# azokat a helyeket, ahol van adat, mentsük el
> not.blanks.v = which(ae2.v!="")
# töröljük az üres helyeket
> szavak.ae2.v = ae2.v[not.blanks.v]
# egyedi szavak
> egyedi.aranyember.v = unique(szavak.ae2.v)
# `magyarlanc`-cal elemzett változót is kisbetűsítsük, de előtte távolítsuk el belőle az írásjelek üres helyét – ha az előző alkalommal nem tettük volna meg –, ezt most nem írom ide, fentebb úgyis olvasható a metódus puskának
> egyedi.szavak.v = unique(szavak.v)
```

    - Ha ellenőrizzük az elkészült két változó hosszúságát (`length(egyedi.aranyember.v)`, `length(egyedi.szavak.v)`), akkor azt találjuk, hogy nem ugyanolyan hosszúak. Nagyon nem. Az okok banálisak.
    - A közvetlenül a szövegfájlból, előzetes elemzés nélkül behívott regényszöveg szavainak egyedisége a szóalak egyeediségét jelenti. Tehát a „kaput”, „kapunak” két külön alak, míg a `magyarlanc`-cal előkészített, és a csak lemma-oszlopot tartalmazó szöveg esetében ez egy alak, a „kapu”. De van más oka is.
    - Amikor kiadtuk az írásjelek eltávolításának Jockersnél olvasható parancsát (`ae.lower.l = strsplit(ae.lower.v, "\\W")`), akkor azt mondtuk, minden nem-karakter írásjelnél kezdjen új elemet. De ez akkor is új elemet kezd, ha a kifejezés történetesen az „1.”, ti. „első”. Ez tehát eszerint a parancs szerint rögtön két elem, a `magyarlanc`-cal ellenőrizve viszont, helyesen, egy. (Nézzük meg: ` head(ae2.v, n=40)` az összes írásjelnél üres elemet fogunk látni.)
    - Ugyanígy az „Athalie-nak” is két elem lesz. Ugyanakkor azt is látni kell, hogy a `magyarlanc` még nem képes korrekten kezelni a kötőjeles alakokat („törte-e”, „Athalie-nak”), ti. nem elemzi jól, bár egy szónak látja őket. Ezért érdemes megfontolni, hogy a szöveget előzetesen preparáljuk, és ezeket a kötőjeles alakokat eltávolítjuk („törte e”, „Athalienak” – én végül a „törte-e” típusú alakokat szétválasztottam, de a többit [pl. „egy-egy”] meghagytam).
- Végül számoljuk ki a különböző TTR-arányokat!

```R
# a lemmákkal számolt értékek
tjv.aranyember = length(egyedi.szavak.v)/length(szavak.v)
jtv.aranyember = length(szavak.v)/length(unique(szavak.v))
# a nyers regényszövegekből számolt értékek (a `valtozo.df`-ből nem a 2., hanem az 1. oszlopot exportáltam, majd írásjeltelenítettem)
tjv.regeny.aranyember = length(unique(regenyszavak.v))/length(regenyszavak.v)
jtv.regeny.aranyember = length(regenyszavak.v)/length(unique(regenyszavak.v))
```
    - Ha ellenőrizzük az egyes értékeket (kiíratjuk magát a változót a változó nevének begépelésével vagy az `RStudio` `environment` fülére kattintva megnézzük az értékeket), akkor láthatjuk, hogy jelentősen eltérnek. Ha felhasználjuk az adatokat, akkor érdemes pontosan jelezni, mit és hogyan számoltunk. Esetleg miért.

### 1.3. Szókeresés
- Egy szót megkeresni roppant egyszerű... Egy sima szövegfájlban – legyen bármilyen formátumban is – a szókeresés alapvetően egy karaktersor keresését jelenti, tehát az „arannyal”, „aranyat” és az „Aranyban” nem feltétlenül jelenik meg az „arany” keresésére. A kisbetű–nagybetű probléma persze könnyen orvosolható, de az „arannyal” problémája már nem. Hiszen ha rövidítem, hogy csak „aran”-ra keressen és ne teljes szavakban, akkor a „parancsol” is megjelenhet, többek között. Két megoldást mutatok, R-ben hogyan keressünk (nyilván: lehetne még máshogy is).

```R
arany.v = grep("arany", szavak.v)
arany2.v = which(szavak.v=="arany")
```
    - A legnagyobb problémát már kiküszöböltük azzal, hogy a `magyarlanc`-cal végzett elemzés szövegét használjuk kiindulópontnak, ti. a ragozott alakokat is megtaláljuk, hiszen a lemma szerepel a szövegünkben. Ugyanakkor van különbség a kettő között, mivel a `which` paranccsal pontosan ezt a karaktersort keresi meg a program, a `grep` esetében azonban már a szó belsejében is keres. Így például megtalálja az „aranysárgá”-t is. Hogy melyikre van szükségünk, döntse el mindenki maga.

### 1.4. Szóeloszlás
- Nézzünk egy egyszerű szóeloszlási példát. *Az arany ember*ből vegyük az elemzések néhány sokat emlegetett elemét, motívumát – kinek mi tetszik –, az „arany” és a „[vörös] hold” kifejezéseket.

```R
# hozzunk létre egy változót, amely olyan hosszú, mint maga a regény (a regény hosszúság az alábbi példában csak a regény szavainak egymásutánját jelenti, tehát az írásjeleket kihagytam – persze dönthetünk máshogy, de akkor ne a `szavak.v`, hanem a `szoveg.v` változó legyen az alap)
regenyido.v = seq(1:length(szavak.v))

# keressük meg az „arany”, „hold”, „üstökös” kifejezéseket a regényben
arany.v = grep("arany", szavak.v)
hold.v = grep("hold", szavak.v)
voros.v = grep("vörös", szavak.v)

# előszor hozzunk létre egy-egy változót, amely olyan hosszú, mint a regény, de a helyek üres elemként jelennek meg (`NA`)
a.count.v = rep(NA, length(szavak.aranyember.v))
h.count.v = rep(NA, length(szavak.aranyember.v))
v.count.v = rep(NA, length(szavak.aranyember.v))

# ezután azokat a helyeket, ahol a korábbiak szerint az „arany”, „hold” és „vörös” kifejezések előfordulnak, kapja meg az `1` értéket
a.count.v[arany.v] = 1
h.count.v[hold.v] = 1
v.count.v[voros.v] = 1
```

Egy csomó mindent még tanulni kell. Majd máskor.

[distant]: https://www.google.hu/search?client=safari&rls=en&q=distant+reading&ie=UTF-8&oe=UTF-8&gfe_rd=cr&ei=7c9DWNqCHKve8geiuL-4DA#newwindow=1&q=distant+reading
[stylo]: https://sites.google.com/site/computationalstylistics/
[r]: https://www.r-project.org
[magyarlanc]: http://www.inf.u-szeged.hu/rgai/magyarlanc
[rstudio]: https://www.rstudio.com
[calibre]: https://calibre-ebook.com
